{"version":3,"sources":["PathVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/aStar.js","PathVisualizer/PathVisualizer.jsx","algorithms/dfs.js","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","AStar","sortByDistance","distanceToFinishNode","PathVisualizer","getInitialGrid","rowCount","state","ROW_COUNT","colCount","COLUMN_COUNT","initialGrid","currentRow","createNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","Math","abs","isNode","mouseIsPressed","MOBILE_ROW_COUNT","MOBILE_COLUMN_COUNT","isRunning","isStartNode","isFinishNode","isWallNode","currRow","currCol","isDesktopView","handleMouseDown","bind","handleMouseLeave","toggleIsRunning","setState","clearGrid","clearWalls","alert","isGridClear","document","getElementById","newGrid","getNewGridWithWallToggled","nodeClassName","slice","algo","nextNodesStack","currentNode","pop","nextNode","dfs","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","animate","i","setTimeout","animateShortestPath","href","type","data-toggle","data-target","aria-controls","aria-expanded","aria-label","onMouseLeave","map","rowIdx","nodeIdx","handleMouseEnter","handleMouseUp","onClick","visualize","toggleView","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ed19f350.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component{\r\n   render() {\r\n      const {\r\n         col, \r\n         isFinish,\r\n         isStart,\r\n         isWall,\r\n         onMouseDown,\r\n         onMouseEnter,\r\n         onMouseUp,\r\n         row,\r\n      } = this.props;\r\n      const extraClassName = isFinish\r\n        ? 'node-finish'\r\n        : isStart\r\n        ? 'node-start'\r\n        : isWall\r\n        ? 'node-wall'\r\n        : '';\r\n      \r\n      return (\r\n        <td\r\n          id={`node-${row}-${col}`}\r\n          className={`node ${extraClassName}`}\r\n          onMouseDown={() => onMouseDown(row, col)}\r\n          onMouseEnter={() => onMouseEnter(row, col)}\r\n          onMouseUp={() => onMouseUp()}></td>\r\n      );\r\n   }\r\n}","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n   const visitedNodesInOrder = [];\r\n   startNode.distance = 0;\r\n   const unvisitedNodes = getAllNodes(grid); \r\n \r\n   while (unvisitedNodes.length) {\r\n     sortNodesByDistance(unvisitedNodes);\r\n     const closestNode = unvisitedNodes.shift();\r\n     //Skip the wall.\r\n     if (!closestNode.isWall) {\r\n       // If the closest node is at a distance of infinity,\r\n       // we must be trapped and should stop.\r\n       if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n       closestNode.isVisited = true;\r\n       visitedNodesInOrder.push(closestNode);\r\n       if (closestNode === finishNode) return visitedNodesInOrder;\r\n       updateUnvisitedNeighbors(closestNode, grid);\r\n     }\r\n   }\r\n }\r\n \r\n function getAllNodes(grid) {\r\n   const nodes = [];\r\n   for (const row of grid) {\r\n     for (const node of row) {\r\n       nodes.push(node);\r\n     }\r\n   }\r\n   return nodes;\r\n }\r\n \r\n function sortNodesByDistance(unvisitedNodes) {\r\n   unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n }\r\n \r\n function updateUnvisitedNeighbors(node, grid) {\r\n   const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n   for (const neighbor of unvisitedNeighbors) {\r\n     neighbor.distance = node.distance + 1;\r\n     neighbor.previousNode = node;\r\n   }\r\n }\r\n \r\n function getUnvisitedNeighbors(node, grid) {\r\n   const neighbors = [];\r\n   const {col, row} = node;\r\n   if (row > 0) neighbors.push(grid[row - 1][col]);\r\n   if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n   if (col > 0) neighbors.push(grid[row][col - 1]);\r\n   if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n   return neighbors.filter(neighbor => !neighbor.isVisited);\r\n }\r\n ","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path by backtracking from the finish node.\r\n// aStar sort of knows about the postion of finish node.\r\n\r\nexport function AStar(grid, startNode, finishNode) {\r\n   const visitedNodesInOrder = [];\r\n   startNode.distance = 0;\r\n   const unvisitedNodes = getAllNodes(grid); \r\n \r\n   while (unvisitedNodes.length) {\r\n     sortByDistance(unvisitedNodes);\r\n     const closestNode = unvisitedNodes.shift();\r\n     // If we encounter a wall, we skip it.\r\n     if (!closestNode.isWall) {\r\n       // If the closest node is at a distance of infinity,\r\n       // we must be trapped and should stop.\r\n       if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n       closestNode.isVisited = true;\r\n       visitedNodesInOrder.push(closestNode);\r\n       if (closestNode === finishNode) return visitedNodesInOrder;\r\n       updateUnvisitedNeighbors(closestNode, grid);\r\n     }\r\n   }\r\n }\r\n \r\n function getAllNodes(grid) {\r\n   const nodes = [];\r\n   for (const row of grid) {\r\n     for (const node of row) {\r\n       nodes.push(node);\r\n     }\r\n   }\r\n   return nodes;\r\n }\r\n \r\n function sortByDistance(unvisitedNodes) {\r\n   unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n }\r\n \r\n function updateUnvisitedNeighbors(node, grid) {\r\n   const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n   for (const neighbor of unvisitedNeighbors) {\r\n     neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\r\n     neighbor.previousNode = node;\r\n   }\r\n }\r\n \r\n function getUnvisitedNeighbors(node, grid) {\r\n   const neighbors = [];\r\n   const {col, row} = node;\r\n   if (row > 0) neighbors.push(grid[row - 1][col]);\r\n   if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n   if (col > 0) neighbors.push(grid[row][col - 1]);\r\n   if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n   return neighbors.filter(neighbor => !neighbor.isVisited);\r\n }","import React, {Component} from 'react';\r\nimport './PathVisualizer.css';\r\nimport Node from './Node/Node';\r\nimport {dijkstra} from '../algorithms/dijkstra';\r\nimport {AStar} from '../algorithms/aStar';\r\nimport {dfs} from '../algorithms/dfs';\r\n\r\n/*This file implements the algorithms, handles the operations on grid*/\r\nexport default class PathVisualizer extends Component {\r\n   constructor() {\r\n     super();\r\n     this.state = {\r\n       grid: [],\r\n       START_NODE_ROW: 6,\r\n       FINISH_NODE_ROW: 6,\r\n       START_NODE_COL: 7,\r\n       FINISH_NODE_COL: 15,\r\n       mouseIsPressed: false,\r\n       ROW_COUNT: 20,\r\n       COLUMN_COUNT: 35,\r\n       MOBILE_ROW_COUNT: 10,\r\n       MOBILE_COLUMN_COUNT: 18,\r\n       isRunning: false,\r\n       isStartNode: false,\r\n       isFinishNode: false,\r\n       isWallNode: false, \r\n       currRow: 0,\r\n       currCol: 0,\r\n       isDesktopView: true,\r\n     };\r\n\r\n     this.handleMouseDown = this.handleMouseDown.bind(this);\r\n     this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n     this.toggleIsRunning = this.toggleIsRunning.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({grid});\r\n  }\r\n\r\n  toggleIsRunning() {\r\n    this.setState({isRunning: !this.state.isRunning});\r\n  }\r\n\r\n  toggleView() {\r\n   if (!this.state.isRunning) {\r\n     this.clearGrid();\r\n     this.clearWalls();\r\n     const isDesktopView = !this.state.isDesktopView;\r\n     let grid;\r\n     if (isDesktopView) {\r\n       grid = this.getInitialGrid(\r\n         this.state.ROW_COUNT,\r\n         this.state.COLUMN_COUNT,\r\n       );\r\n       this.setState({isDesktopView, grid});\r\n     } else {\r\n       if (\r\n         this.state.START_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\r\n         this.state.FINISH_NODE_ROW > this.state.MOBILE_ROW_COUNT ||\r\n         this.state.START_NODE_COL > this.state.MOBILE_COLUMN_COUNT ||\r\n         this.state.FINISH_NODE_COL > this.state.MOBILE_COLUMN_COUNT\r\n       ) {\r\n         alert('Start and Finish Nodes Must Be within 10 Rows x 18 Columns');\r\n       } else {\r\n         grid = this.getInitialGrid(\r\n           this.state.MOBILE_ROW_COUNT,\r\n           this.state.MOBILE_COLUMN_COUNT,\r\n         );\r\n         this.setState({isDesktopView, grid});\r\n       }\r\n     }\r\n   }\r\n }\r\n\r\n /* Initial Grid Setup */\r\n getInitialGrid = (\r\n   rowCount = this.state.ROW_COUNT,\r\n   colCount = this.state.COLUMN_COUNT,\r\n ) => {\r\n   const initialGrid = [];\r\n   for (let row = 0; row < rowCount; row++) {\r\n     const currentRow = [];\r\n     for (let col = 0; col < colCount; col++) {\r\n       currentRow.push(this.createNode(row, col));\r\n     }\r\n     initialGrid.push(currentRow);\r\n   }\r\n   return initialGrid;\r\n };\r\n\r\n createNode = (row, col) => {\r\n   return {\r\n     row,\r\n     col,\r\n     isStart:\r\n       row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n     isFinish:\r\n       row === this.state.FINISH_NODE_ROW &&\r\n       col === this.state.FINISH_NODE_COL,\r\n     distance: Infinity,\r\n     distanceToFinishNode:\r\n       Math.abs(this.state.FINISH_NODE_ROW - row) +\r\n       Math.abs(this.state.FINISH_NODE_COL - col),\r\n     isVisited: false,\r\n     isWall: false,\r\n     previousNode: null,\r\n     isNode: true,\r\n   };\r\n };\r\n\r\n /* Mouse Events */\r\n\r\n handleMouseDown(row, col) {\r\n   if (!this.state.isRunning) {\r\n     if (this.isGridClear()) {\r\n       if (\r\n         document.getElementById(`node-${row}-${col}`).className === 'node node-start'\r\n          ) {\r\n         this.setState({\r\n           mouseIsPressed: true,\r\n           isStartNode: true,\r\n           currRow: row,\r\n           currCol: col,\r\n         });\r\n       } else if (\r\n         document.getElementById(`node-${row}-${col}`).className === 'node node-finish'\r\n         ) {\r\n         this.setState({\r\n           mouseIsPressed: true,\r\n           isFinishNode: true,\r\n           currRow: row,\r\n           currCol: col,\r\n         });\r\n       } else {\r\n         const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n         this.setState({\r\n           grid: newGrid,\r\n           mouseIsPressed: true,\r\n           isWallNode: true,\r\n           currRow: row,\r\n           currCol: col,\r\n         });\r\n       }\r\n     } else {\r\n       this.clearGrid();\r\n     }\r\n   }\r\n }\r\n\r\n isGridClear() {\r\n   for (const row of this.state.grid) {\r\n     for (const node of row) {\r\n       const nodeClassName = document.getElementById(\r\n         `node-${node.row}-${node.col}`, \r\n         ).className;\r\n       if (\r\n         nodeClassName === 'node node-visited' || \r\n         nodeClassName === 'node node-shortest-path'\r\n         ) {\r\n         return false;\r\n       }\r\n     }\r\n   }\r\n   return true;\r\n }\r\n\r\n \r\n \r\n handleMouseEnter(row, col) {\r\n   if (!this.state.isRunning) {\r\n     if (this.state.mouseIsPressed) {\r\n       const nodeClassName = document.getElementById(`node-${row}-${col}`)\r\n         .className;\r\n       if (this.state.isStartNode) {\r\n         if (nodeClassName !== 'node node-wall') {\r\n           const prevStartNode = this.state.grid[this.state.currRow][\r\n             this.state.currCol\r\n           ];\r\n           prevStartNode.isStart = false;\r\n           document.getElementById(\r\n             `node-${this.state.currRow}-${this.state.currCol}`,\r\n           ).className = 'node';\r\n\r\n           this.setState({currRow: row, currCol: col});\r\n           const currStartNode = this.state.grid[row][col];\r\n           currStartNode.isStart = true;\r\n           document.getElementById(`node-${row}-${col}`).className =\r\n             'node node-start';\r\n         }\r\n         this.setState({START_NODE_ROW: row, START_NODE_COL: col});\r\n       } else if (this.state.isFinishNode) {\r\n         if (nodeClassName !== 'node node-wall') {\r\n           const prevFinishNode = this.state.grid[this.state.currRow][\r\n             this.state.currCol\r\n           ];\r\n           prevFinishNode.isFinish = false;\r\n           document.getElementById(\r\n             `node-${this.state.currRow}-${this.state.currCol}`,\r\n           ).className = 'node';\r\n\r\n           this.setState({currRow: row, currCol: col});\r\n           const currFinishNode = this.state.grid[row][col];\r\n           currFinishNode.isFinish = true;\r\n           document.getElementById(`node-${row}-${col}`).className =\r\n             'node node-finish';\r\n         }\r\n         this.setState({FINISH_NODE_ROW: row, FINISH_NODE_COL: col});\r\n       } else if (this.state.isWallNode) {\r\n         const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n         this.setState({grid: newGrid});\r\n       }\r\n     }\r\n   }\r\n }\r\n\r\n handleMouseUp(row, col) {\r\n   if (!this.state.isRunning) {\r\n     this.setState({mouseIsPressed: false});\r\n     if (this.state.isStartNode) {\r\n       const isStartNode = !this.state.isStartNode;\r\n       this.setState({isStartNode, START_NODE_ROW: row, START_NODE_COL: col});\r\n     } else if (this.state.isFinishNode) {\r\n       const isFinishNode = !this.state.isFinishNode;\r\n       this.setState({\r\n         isFinishNode,\r\n         FINISH_NODE_ROW: row,\r\n         FINISH_NODE_COL: col,\r\n       });\r\n     }\r\n     this.getInitialGrid();\r\n   }\r\n }\r\n\r\n handleMouseLeave() {\r\n   if (this.state.isStartNode) {\r\n     const isStartNode = !this.state.isStartNode;\r\n     this.setState({isStartNode, mouseIsPressed: false});\r\n   } else if (this.state.isFinishNode) {\r\n     const isFinishNode = !this.state.isFinishNode;\r\n     this.setState({isFinishNode, mouseIsPressed: false});\r\n   } else if (this.state.isWallNode) {\r\n     const isWallNode = !this.state.isWallNode;\r\n     this.setState({isWallNode, mouseIsPressed: false});\r\n     this.getInitialGrid();\r\n   }\r\n }\r\n\r\n /*This section is for clearing walls from the board */\r\n\r\n clearGrid() {\r\n   if (!this.state.isRunning) {\r\n     const newGrid = this.state.grid.slice();\r\n     for (const row of newGrid) {\r\n       for (const node of row) {\r\n         let nodeClassName = document.getElementById(\r\n           `node-${node.row}-${node.col}`,\r\n           ).className;\r\n         if (\r\n           nodeClassName !== 'node node-start' &&\r\n           nodeClassName !== 'node node-finish' &&\r\n           nodeClassName !== 'node node-wall'\r\n         ) {\r\n           document.getElementById(`node-${node.row}-${node.col}`).className =\r\n             'node';\r\n           node.isVisited = false;\r\n           node.distance = Infinity;\r\n           node.distanceToFinishNode =\r\n             Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n             Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n         }\r\n         if (nodeClassName === 'node node-finish') {\r\n           node.isVisited = false;\r\n           node.distance = Infinity;\r\n           node.distanceToFinishNode = 0;\r\n         }\r\n         if (nodeClassName === 'node node-start') {\r\n           node.isVisited = false;\r\n           node.distance = Infinity;\r\n           node.distanceToFinishNode =\r\n             Math.abs(this.state.FINISH_NODE_ROW - node.row) +\r\n             Math.abs(this.state.FINISH_NODE_COL - node.col);\r\n           node.isStart = true;\r\n           node.isWall = false;\r\n           node.previousNode = null;\r\n           node.isNode = true;\r\n         }\r\n       }\r\n     }\r\n   }\r\n }\r\n\r\n clearWalls() {\r\n   if (!this.state.isRunning) {\r\n     const newGrid = this.state.grid.slice();\r\n     for (const row of newGrid) {\r\n       for (const node of row) {\r\n         let nodeClassName = document.getElementById(\r\n           `node-${node.row}-${node.col}`,\r\n         ).className;\r\n         if (nodeClassName === 'node node-wall') {\r\n           document.getElementById(`node-${node.row}-${node.col}`).className =\r\n             'node';\r\n           node.isWall = false;\r\n         }\r\n       }\r\n     }\r\n   }\r\n }\r\n\r\n/*This section handles the animations */\r\nvisualize(algo) {\r\n   if (!this.state.isRunning) {\r\n     this.clearGrid();\r\n     this.toggleIsRunning();\r\n     const {grid} = this.state;\r\n     const startNode =\r\n       grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n     const finishNode =\r\n       grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n     let visitedNodesInOrder;\r\n     switch (algo) {\r\n       case 'Dijkstra':\r\n         visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n         break;\r\n       case 'AStar':\r\n         visitedNodesInOrder = AStar(grid, startNode, finishNode);\r\n         break;\r\n       case 'DFS':\r\n         visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n         break;\r\n       default:\r\n         // should never get here\r\n         break;\r\n     }\r\n     //getNodesInShortestPathOrder function defined at the end\r\n     const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n     nodesInShortestPathOrder.push('end');\r\n     this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n   }\r\n }\r\n\r\n animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n   for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n     if (i === visitedNodesInOrder.length) {\r\n       setTimeout(() => {\r\n         this.animateShortestPath(nodesInShortestPathOrder);\r\n       }, 10 * i);\r\n       return;\r\n     }\r\n     setTimeout(() => {\r\n       const node = visitedNodesInOrder[i];\r\n       const nodeClassName = document.getElementById(\r\n         `node-${node.row}-${node.col}`,\r\n       ).className;\r\n       if (\r\n         nodeClassName !== 'node node-start' &&\r\n         nodeClassName !== 'node node-finish'\r\n       ) {\r\n         document.getElementById(`node-${node.row}-${node.col}`).className =\r\n           'node node-visited';\r\n       }\r\n     }, 10 * i);\r\n   }\r\n }\r\n\r\n /*Plot path from start to finish node */\r\n\r\n animateShortestPath(nodesInShortestPathOrder) {\r\n   for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n     if (nodesInShortestPathOrder[i] === 'end') {\r\n       setTimeout(() => {\r\n         this.toggleIsRunning();\r\n       }, i * 50);\r\n     } else {\r\n       setTimeout(() => {\r\n         const node = nodesInShortestPathOrder[i];\r\n         const nodeClassName = document.getElementById(\r\n           `node-${node.row}-${node.col}`,\r\n         ).className;\r\n         if (\r\n           nodeClassName !== 'node node-start' &&\r\n           nodeClassName !== 'node node-finish'\r\n         ) {\r\n           document.getElementById(`node-${node.row}-${node.col}`).className =\r\n             'node node-shortest-path';\r\n         }\r\n       }, i * 40);\r\n     }\r\n   }\r\n }\r\n/*Top Bar */\r\n render() {\r\n   const {grid, mouseIsPressed} = this.state;\r\n   return (\r\n      <div>\r\n       <nav className=\"navbar navbar-expand-lg navbar-dark bg-dark \">\r\n         <a className=\"navbar-brand\" href=\"/\">\r\n           <b>PathFinding Visualizer</b>\r\n         </a>\r\n         <button\r\n            className=\"navbar-toggler\"\r\n            type=\"button\"\r\n            data-toggle=\"collapse\"\r\n            data-target=\"#navbarNav\"\r\n            aria-controls=\"navbarNav\"\r\n            aria-expanded=\"false\"\r\n            aria-label=\"Toggle navigation\">\r\n            <span className=\"navbar-toggler-icon\"></span>\r\n         </button>\r\n         </nav>\r\n\r\n{/*grid-container */}\r\n         <table\r\n          className=\"grid-container\"\r\n          onMouseLeave={() => this.handleMouseLeave()}>\r\n          <tbody className=\"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <tr key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const {row, col, isFinish, isStart, isWall} = node;\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        col={col}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                        onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                        onMouseUp={() => this.handleMouseUp(row, col)}\r\n                        row={row}></Node>\r\n                    );\r\n                  })}\r\n                </tr>\r\n              );\r\n            })}\r\n          </tbody>\r\n        </table>\r\n\r\n        {/*Buttons, className for adding bootstrap colors*/}\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-warning\"\r\n          onClick={() => this.clearGrid()}>\r\n          Clear Grid\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-danger\"\r\n          onClick={() => this.clearWalls()}>\r\n          Clear Walls\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.visualize('Dijkstra')}>\r\n          Dijkstra's\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.visualize('AStar')}>\r\n          A*\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          className=\"btn btn-primary\"\r\n          onClick={() => this.visualize('DFS')}>\r\n          Depth First Search\r\n        </button>\r\n        {this.state.isDesktopView ? (\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-light\"\r\n            onClick={() => this.toggleView()}>\r\n            Mobile View\r\n          </button>\r\n        ) : (\r\n          <button\r\n            type=\"button\"\r\n            className=\"btn btn-dark\"\r\n            onClick={() => this.toggleView()}>\r\n            Desktop View\r\n          </button>\r\n        )}\r\n      </div>\r\n     );\r\n   }\r\n}\r\n\r\n/* Create Walls */\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n   // because of mouseDown issue \r\n   const newGrid = grid.slice();\r\n   const node = newGrid[row][col];\r\n   if (!node.isStart && !node.isFinish && node.isNode) {\r\n     const newNode = {\r\n       ...node,\r\n       isWall: !node.isWall,\r\n     };\r\n     newGrid[row][col] = newNode;\r\n   }\r\n   return newGrid;\r\n };\r\n \r\n // Backtracks from the finishNode to find the shortest path.\r\n // Only works when called after the pathfinding methods.\r\n function getNodesInShortestPathOrder(finishNode) {\r\n   const nodesInShortestPathOrder = [];\r\n   let currentNode = finishNode;\r\n   while (currentNode !== null) {\r\n     nodesInShortestPathOrder.unshift(currentNode);\r\n     currentNode = currentNode.previousNode;\r\n   }\r\n   return nodesInShortestPathOrder;\r\n }","// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path by backtracking from the finish node.\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n   const visitedNodesInOrder = [];\r\n   const nextNodesStack = [];\r\n   nextNodesStack.push(startNode);\r\n   while (nextNodesStack.length) {\r\n     const currentNode = nextNodesStack.pop();\r\n \r\n     if (currentNode === finishNode) {\r\n       return visitedNodesInOrder;\r\n     }\r\n \r\n     if (\r\n       !currentNode.isWall &&\r\n       (currentNode.isStart || !currentNode.isVisited)\r\n     ) {\r\n       currentNode.isVisited = true;\r\n       visitedNodesInOrder.push(currentNode);\r\n \r\n       const {col, row} = currentNode;\r\n       let nextNode;\r\n       if (row > 0) {\r\n         nextNode = grid[row - 1][col];\r\n         if (!nextNode.isVisited) {\r\n           nextNode.previousNode = currentNode;\r\n           nextNodesStack.push(nextNode);\r\n         }\r\n       }\r\n       if (row < grid.length - 1) {\r\n         nextNode = grid[row + 1][col];\r\n         if (!nextNode.isVisited) {\r\n           nextNode.previousNode = currentNode;\r\n           nextNodesStack.push(nextNode);\r\n         }\r\n       }\r\n       if (col > 0) {\r\n         nextNode = grid[row][col - 1];\r\n         if (!nextNode.isVisited) {\r\n           nextNode.previousNode = currentNode;\r\n           nextNodesStack.push(nextNode);\r\n         }\r\n       }\r\n       if (col < grid[0].length - 1) {\r\n         nextNode = grid[row][col + 1];\r\n         if (!nextNode.isVisited) {\r\n           nextNode.previousNode = currentNode;\r\n           nextNodesStack.push(nextNode);\r\n         }\r\n       }\r\n     }\r\n   }\r\n }","/*import logo from './logo.svg';*/\nimport './App.css';\nimport React from 'react';\nimport PathVisualizer from './PathVisualizer/PathVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathVisualizer>jhhj</PathVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","//check this code\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}